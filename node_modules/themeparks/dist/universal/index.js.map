{"version":3,"sources":["../../lib/universal/index.js"],"names":["Park","require","Moment","crypto","api_baseURL","api_appKey","api_appSecret","s_parkID","Symbol","s_city","UniversalPark","options","name","scheduleDaysToReturn","park_id","Error","park_city","receivedTtl","Cache","Wrap","Promise","resolve","reject","today","utc","format","signatureBuilder","createHmac","update","signature","digest","replace","HTTP","url","method","headers","Date","body","apiKey","then","Token","Log","toString","expireyDate","TokenExpirationString","now","diff","bind","err","requestObject","GetAccessToken","access_token","Accept","GetAPIUrl","data","city","Rides","i","ride","VenueId","rideObject","GetRideObject","id","Id","MblDisplayName","WaitTime","FastPass","ExpressPassAccepted","hoursEndDate","add","endDate","length","day","Schedule","SetDate","openingTime","tz","OpenTimeString","Timezone","closingTime","CloseTimeString","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\n\n// include core Park class\nvar Park = require(\"../park\");\nvar Moment = require(\"moment-timezone\");\n\n// crypto lib for generating access token signature\nvar crypto = require(\"crypto\");\n\n// API settings\nvar api_baseURL = \"https://services.universalorlando.com/api/\";\nvar api_appKey = \"AndroidMobileApp\";\nvar api_appSecret = \"AndroidMobileAppSecretKey182014\";\n\nvar s_parkID = Symbol();\nvar s_city = Symbol();\n\n// park IDs:\n//  Studios: 10010\n//  Islands: 10000\n//  CityWalk: 10011\n//  Wet 'N Wild: 45084\n\n/**\n * Implements the Universal API framework. All Universal parks use this one API.\n * @class\n * @extends Park\n */\nclass UniversalPark extends Park {\n    /**\n     * Create new UniversalPark Object.\n     * This object should not be called directly, but rather extended for each of the individual Universal parks\n     * @param {Object} options\n     * @param {String} options.park_id Universal API park ID\n     */\n    constructor(options = {}) {\n        options.name = options.name || \"Universal Park\";\n\n        // Universal parks return lots of opening time data, return a few months of data by default\n        options.scheduleDaysToReturn = options.scheduleDaysToReturn || 90;\n\n        // inherit from base class\n        super(options);\n\n        // grab Universal API configs for this park instance\n        if (!options.park_id) throw new Error(\"Missing park's API ID\");\n        this[s_parkID] = options.park_id;\n\n        // universal hollywood uses ?city= on it's API requests, so optionally support setting that\n        this[s_city] = options.park_city;\n    }\n\n    // override Fastpass Getter to declare support for FastPass\n    get FastPass() {\n        return true;\n    }\n\n    /**\n     * Get our current access token\n     * @returns {Promise}\n     */\n    GetAccessToken() {\n        var receivedTtl;\n\n        return this.Cache.Wrap(\"accesstoken\", function() {\n            return new Promise(function(resolve, reject) {\n                // Get access token\n                // generate access token signature\n                //  calculate current date to generate access token signature\n                var today = Moment.utc().format(\"ddd, DD MMM YYYY HH:mm:ss\") + \" GMT\";\n\n                // create signature to get access token\n                var signatureBuilder = crypto.createHmac(\"sha256\", api_appSecret);\n                signatureBuilder.update(api_appKey + \"\\n\" + today + \"\\n\");\n                // generate hash from signature builder\n                //  also convert trailing equal signs to unicode. because. I don't know\n                var signature = signatureBuilder.digest(\"base64\").replace(/=$/, \"\\u003d\");\n\n                // request new access token\n                this.HTTP({\n                    url: api_baseURL,\n                    method: \"POST\",\n                    headers: {\n                        Date: today\n                    },\n                    body: {\n                        apiKey: api_appKey,\n                        signature: signature,\n                    }\n                }).then(\n                    function(body) {\n                        // check we actually got the token back\n                        if (!body.Token) {\n                            this.Log(body.toString(\"ascii\"));\n                            return reject(\"Missing access token from Universal API\");\n                        }\n\n                        var expireyDate = Moment(body.TokenExpirationString, \"YYYY-MM-DDTHH:mm:ssZ\");\n                        var now = Moment();\n                        // expire this access token a minute before the API says (just to be sure)\n                        receivedTtl = expireyDate.diff(now, \"seconds\") - 60;\n\n                        // resolve with our new access token (Wrap will cache for us)\n                        resolve(body.Token);\n                    }.bind(this),\n                    function(err) {\n                        this.Log(\"Error fetching Universal Access Token: \" + err);\n                        return reject(err);\n                    }.bind(this)\n                );\n            }.bind(this));\n        }.bind(this), function() {\n            // Ttl callback setter\n            return receivedTtl;\n        }.bind(this));\n    }\n\n    /**\n     * Fetch a URL from the Universal API\n     */\n    GetAPIUrl(requestObject) {\n        return this.GetAccessToken().then(function(access_token) {\n            // make sure headers exist if they weren't set already\n            if (!requestObject.headers) requestObject.headers = [];\n            requestObject.headers.Accept = \"application/json\";\n            requestObject.headers[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n            requestObject.headers[\"Accept-Language\"] = \"en-US\";\n\n            // add our access token to the request\n            if (access_token) {\n                requestObject.headers[\"X-UNIWebService-ApiKey\"] = api_appKey;\n                requestObject.headers[\"X-UNIWebService-Token\"] = access_token;\n            }\n\n            // send network request\n            return this.HTTP(requestObject);\n        }.bind(this));\n    }\n\n    /**\n     * Fetch this Universal Park's waiting times\n     * @returns {Promise}\n     */\n    FetchWaitTimes() {\n        return new Promise(function(resolve, reject) {\n            // ride wait time data is kept in the pointsOfInterest URL\n            this.GetAPIUrl({\n                url: api_baseURL + \"pointsOfInterest\",\n                data: this[s_city] ? {\n                    city: this[s_city]\n                } : null\n            }).then(function(body) {\n                if (!body || !body.Rides) return reject(\"Universal POI data missing Rides array\");\n\n                for (var i = 0, ride; ride = body.Rides[i++];) {\n                    // skip if this ride isn't for our current park\n                    // TODO - store poiData separately for both parks to access\n                    if (ride.VenueId != this[s_parkID]) continue;\n\n                    // waitTimes assumed key:\n                    //  -1 seems to mean \"closed\"\n                    //  -2 means \"delayed\", which I guess is a nice way of saying \"broken\"\n                    //  -3 and -50 seems to mean planned closure\n\n                    // find/create this ride\n                    var rideObject = this.GetRideObject({\n                        id: ride.Id,\n                        name: ride.MblDisplayName\n                    });\n\n                    // update wait time\n                    rideObject.WaitTime = ride.WaitTime;\n                    // update FastPass status\n                    rideObject.FastPass = ride.ExpressPassAccepted;\n                }\n\n                resolve();\n            }.bind(this), reject);\n        }.bind(this));\n    }\n\n    /**\n     * Fetch this Universal Park's opening times\n     * @returns {Promise}\n     */\n    FetchOpeningTimes() {\n        return new Promise(function(resolve, reject) {\n            // pick a date 1 month from now (in middle/lowest/highest form MM/DD/YYYY, because I don't know)\n            var hoursEndDate = Moment().add(12, \"months\").format(\"MM/DD/YYYY\");\n\n            this.GetAPIUrl({\n                url: api_baseURL + `venues/${this[s_parkID]}/hours`,\n                data: {\n                    endDate: hoursEndDate,\n                    city: this[s_city] ? this[s_city] : null\n                }\n            }).then(function(body) {\n                if (!body || !body.length) return reject(\"No venue hour data found from Universal API\");\n\n                // find all published opening times for the next year and insert into our schedule\n                for (var i = 0, day; day = body[i++];) {\n                    this.Schedule.SetDate({\n                        // for ease, we'll just parse the Unix timestamp\n                        openingTime: Moment.tz(day.OpenTimeString, \"YYYY-MM-DDTHH:mm:ssZ\", this.Timezone),\n                        closingTime: Moment.tz(day.CloseTimeString, \"YYYY-MM-DDTHH:mm:ssZ\", this.Timezone)\n                    });\n                }\n\n                resolve();\n            }.bind(this), reject);\n        }.bind(this));\n    }\n}\n\n// export the class\nmodule.exports = UniversalPark;"]}