{"version":3,"sources":["../../lib/efteling/index.js"],"names":["crypto","require","Moment","Park","GeoLocation","s_apiVersion","Symbol","s_cryptoKey","s_cryptoCipher","s_cryptoIV","s_digestKey","s_searchURL","s_waitTimesURL","Efteling","options","name","timezone","latitude","longitude","api_version","digest_key","crypto_key","crypto_cipher","crypto_iv","Buffer","search_url","wait_times_url","Cache","Wrap","FetchPOIData","bind","MakeRequest","url","data","then","result","hits","hit","Error","poiData","map","fields","category","id","latlon","match","exec","location","GetPOIData","FetchWaitTimesData","waitData","AttractionInfo","item","Type","Id","rideObject","GetRideObject","WaitTime","State","parseInt","WaitingTime","Promise","resolve","decodedBuffer","from","toString","decipher","createDecipheriv","concat","update","final","replace","hmac","createHmac","digest","requestOptions","error","GetDigest","Log","headers","body","returnFullResponse","json","HTTP","response","reject","constructor","JSONResult","JSON","parse","e","decryptedString","DecryptString","endMonth","tz","Timezone","add","ScheduleDays","datePointer","months","format","isSameOrBefore","push","month","year","all","FetchOpeningTimesByMonth","results","hours","times","Schedule","SetDate","date","open","openingTime","closingTime","close","OpeningHours","i","Date","Open","Close","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const crypto = require(\"crypto\");\nconst Moment = require(\"moment-timezone\");\n\nconst Park = require(\"../park\");\n\nconst GeoLocation = require(\"../geoLocation.js\");\n\nconst s_apiVersion = Symbol();\nconst s_cryptoKey = Symbol();\nconst s_cryptoCipher = Symbol();\nconst s_cryptoIV = Symbol();\nconst s_digestKey = Symbol();\nconst s_searchURL = Symbol();\nconst s_waitTimesURL = Symbol();\n\n/**\n * Implements the Efteling API framework.\n * @class\n * @extends Park\n */\nclass Efteling extends Park {\n    /**\n     * Create new Efteling Object.\n     * @param {Object} [options]\n     * @param {String} [options.api_version] Version of the API to reference in request headers\n     * @param {String} [options.digest_key] Key used to generate URL header digest\n     * @param {String} [options.crypto_key] Key to decrypt wait times\n     * @param {String} [options.crypto_cipher] Cipher to decrypt wait times\n     * @param {Buffer} [options.crypto_iv] IV to decrypt wait times\n     * @param {String} [options.search_url] URL used for fetching POI data\n     */\n    constructor(options = {}) {\n        options.name = options.name || \"Efteling\";\n\n        options.timezone = options.timezone || \"Europe/Amsterdam\";\n\n        // set park's location as it's entrance\n        options.latitude = options.latitude || 51.64990915659694;\n        options.longitude = options.longitude || 5.043561458587647;\n\n        // inherit from base class\n        super(options);\n\n        // api settings\n        this[s_apiVersion] = options.api_version || \"4\";\n\n        // URL generation settings\n        this[s_digestKey] = options.digest_key || \"blblblblbla\";\n\n        // decryption settings\n        this[s_cryptoKey] = options.crypto_key || \"1768257091023496\";\n        this[s_cryptoCipher] = options.crypto_cipher || \"aes-128-cbc\";\n        this[s_cryptoIV] = options.crypto_iv || new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\n        // URL settings\n        this[s_searchURL] = options.search_url || \"http://prd-search-acs.efteling.com/2013-01-01/\";\n        this[s_waitTimesURL] = options.wait_times_url || \"https://mobile-services.efteling.com/wis/\";\n    }\n\n    /**\n     * Get POI data for this park (from the cache or fetch fresh data if none is cached)\n     * @returns {Promise}\n     */\n    GetPOIData() {\n        return this.Cache.Wrap(\"poidata\", this.FetchPOIData.bind(this), 60 * 60 * 24);\n    }\n\n    /**\n     * Fetch POI data for the park.\n     * Don't call this function directly unless you know what you're doing. Use GetPOIData instead to use cached data when possible.\n     * @returns {Promise} Object of Ride IDs => Object containing name and location (GeoLocation object, if location is available for this ride)\n     */\n    FetchPOIData() {\n        return this.MakeRequest({\n            url: `${this[s_searchURL]}search`,\n            data: {\n                \"size\": 1000,\n                \"q.parser\": \"structured\",\n                \"q\": \"(phrase field=language 'en')\"\n            }\n        }).then((result) => {\n            if (!result || !result.hits || !result.hits.hit) {\n                throw new Error(`No results returned for POI data for Efteling Park: ${result}`);\n            }\n\n            var poiData = {};\n\n            result.hits.hit.map((hit) => {\n                if (hit.fields) {\n                    // ignore non-attractions\n                    if (hit.fields.category == \"attraction\") {\n                        poiData[hit.fields.id] = {\n                            name: hit.fields.name,\n                        };\n\n                        // try to parse lat/long\n                        //  edge-case: some rides have dud \"0.0,0.0\" location, ignore these\n                        if (hit.fields.latlon && hit.fields.latlon != \"0.0,0.0\") {\n                            var match = /([0-9.]+),([0-9.]+)/.exec(hit.fields.latlon);\n                            if (match) {\n                                poiData[hit.fields.id].location = new GeoLocation({\n                                    latitude: match[1],\n                                    longitude: match[2]\n                                });\n                            }\n                        }\n                    }\n                }\n            });\n\n            return poiData;\n        });\n    }\n\n    /**\n     * Fetch park wait times\n     * @returns {Promise}\n     */\n    FetchWaitTimes() {\n        // first, get POI data\n        return this.GetPOIData().then((poiData) => {\n            // then, get latest wait time results\n            return this.FetchWaitTimesData().then((waitData) => {\n                // parse and inject into park data\n                if (!waitData.AttractionInfo) throw new Error(\"No AttractionInfo found for Efteling Park response\");\n\n                waitData.AttractionInfo.map((item) => {\n                    // check we have POI data and item is an attraction\n                    if (item.Type == \"Attraction\" && poiData[item.Id]) {\n                        var rideObject = this.GetRideObject({\n                            id: item.Id,\n                            name: poiData[item.Id].name\n                        });\n\n                        if (rideObject) {\n                            // update ride with wait time data\n                            //  if the State isn't \"open\", assume ride is closed\n                            // TODO - learn how Efteling marks rides as under refurb and set = -2\n                            rideObject.WaitTime = item.State == \"open\" ? parseInt(item.WaitingTime, 10) : -1;\n                        }\n                    }\n                });\n\n                return Promise.resolve();\n            });\n        });\n    }\n\n    /**\n     * Fetch the raw wait times data for Efteling Park\n     */\n    FetchWaitTimesData() {\n        return this.MakeRequest({\n            url: this[s_waitTimesURL]\n        });\n    }\n\n    /**\n     * Decrypt an encrypted string from the Efteling API\n     * @param {String|Buffer} data \n     */\n    DecryptString(data) {\n        // step 1: decode Base64 (make sure it's in ascii format first, since it's a base64 string in text, not actual base64 data)\n        const decodedBuffer = Buffer.from(data.toString(\"ascii\"), \"base64\");\n        // step 2: setup decryption\n        const decipher = crypto.createDecipheriv(this[s_cryptoCipher], this[s_cryptoKey], this[s_cryptoIV]);\n        // step 3: decrypt and return as utf8 string\n        return Buffer.concat([\n            decipher.update(decodedBuffer),\n            decipher.final()\n        ]).toString(\"utf8\");\n    }\n\n    /**\n     * Generate a digest for given URL\n     * @param {String} URL\n     */\n    GetDigest(url) {\n        // remove http(s) from string\n        url = url.replace(/^https?:\\/\\//, \"\");\n        // generate digest\n        const hmac = crypto.createHmac(\"sha256\", this[s_digestKey]);\n        hmac.update(url);\n        return hmac.digest(\"hex\");\n    }\n\n    /**\n     * Make an API request against the Efteling API\n     * Injects required headers and passes request through to standard HTTP method\n     * See HTTP for full documentation on how to use\n     * @param {Object} requestOptions \n     * @return {Promise}\n     */\n    MakeRequest(requestOptions) {\n        if (!requestOptions.url) {\n            return Promise.error(\"No URL supplied\");\n        }\n\n        // generate digest needed to make URL request\n        const digest = this.GetDigest(requestOptions.url);\n        this.Log(`Generated digest for url \"${requestOptions.url}\": ${digest}`);\n\n        // add our required headers\n        if (!requestOptions.headers) requestOptions.headers = {};\n        requestOptions.headers[\"X-Digest\"] = digest;\n        requestOptions.headers[\"X-Api-Version\"] = this[s_apiVersion];\n\n        if (requestOptions.body || requestOptions.data) {\n            requestOptions.headers[\"Content-Type\"] = \"application/json\";\n        }\n\n        // return full body (so we don't try to auto-parse JSON data as it's often encrypted)\n        requestOptions.returnFullResponse = true;\n        // don't auto-JSON request or response\n        requestOptions.json = false;\n\n        return this.HTTP(requestOptions).then((response) => {\n            // intercept the HTTP method's response to sort out any encrypted data responses...\n\n            if (!response.body) return Promise.reject(\"Failed to get network response\");\n\n            // check if we've already got a valid JSON object as a response\n            if (response.body.constructor === {}.constructor || response.body.constructor === [].constructor) {\n                return Promise.resolve(response.body);\n            }\n\n            // try to parse result body into JSON first\n            var JSONResult;\n            try {\n                JSONResult = JSON.parse(response.body);\n                return Promise.resolve(JSONResult);\n            } catch (e) {\n                // failed to parse JSON data? assume it's encrypted and decrypt it first\n                var decryptedString;\n                try {\n                    decryptedString = this.DecryptString(response.body);\n                } catch (e) {\n                    throw new Error(`Failed to decrypt string: ${response.body}`);\n                }\n\n                // got decrypted string, try to parse it\n                try {\n                    JSONResult = JSON.parse(decryptedString);\n                    return Promise.resolve(JSONResult);\n                } catch (e) {\n                    // also failed to parse decrypted data? reject\n                    throw new Error(`Failed to parse decrypted Efteling string: ${decryptedString}`);\n                }\n            }\n        });\n    }\n\n    /**\n     * Request park opening times.\n     * @returns {Promise}\n     */\n    FetchOpeningTimes() {\n        // calculate how many (and which) months we want to check\n        const endMonth = Moment().tz(this.Timezone).add(this.ScheduleDays, \"days\");\n        var datePointer = Moment().tz(this.Timezone);\n        const months = [];\n\n        this.Log(`Fetching opening hours between ${datePointer.format()} and ${endMonth.format()}`);\n\n        // slide along between start and end until we go past endMonth to get an array of required month/year combos\n        while (datePointer.isSameOrBefore(endMonth, \"month\")) {\n            months.push({\n                month: datePointer.format(\"M\"),\n                year: datePointer.format(\"YYYY\")\n            });\n            datePointer.add(1, \"months\");\n        }\n\n        // loop through each month, calling FetchOpeningTimesByMonth\n        return Promise.all(months.map((month) => {\n            return this.FetchOpeningTimesByMonth(month.month, month.year);\n        })).then((results) => {\n            // inject results into calendar\n            results.map((hours) => {\n                hours.map((times) => {\n                    this.Schedule.SetDate({\n                        date: times.open,\n                        openingTime: times.open,\n                        closingTime: times.close\n                    });\n                });\n            });\n            return results;\n        });\n    }\n\n    /**\n     * Fetch park opening times for a specific month and add to park's opening times\n     * @param {String} month\n     * @param {String} [year]\n     * @returns {Promise} Array of Objects containing \"open\" and \"close\" Moment objects\n     */\n    FetchOpeningTimesByMonth(month, year) {\n        // default to current year if none supplied\n        if (!year) {\n            year = Moment.tz(this.Timezone).format(\"YYYY\");\n        }\n\n        return this.HTTP({\n            url: `https://www.efteling.com/service/cached/getpoiinfo/en/${year}/${month}`,\n            headers: {\n                \"X-Requested-With\": \"XMLHttpRequest\"\n            }\n        }).then((data) => {\n            if (!data) throw new Error(`Invalid data returned for park opening hours for ${month}/${year}`);\n            if (!data.OpeningHours) throw new Error(`No park opening hours data returned for ${month}/${year}`);\n\n            // build array of Moment objects for each open and close time\n            const result = [];\n            for (var i = 0, date; date = data.OpeningHours[i++];) {\n                const open = Moment.tz(`${date.Date}${date.Open}`, \"YYYY-MM-DDHH:mm\", this.Timezone);\n                const close = Moment.tz(`${date.Date}${date.Close}`, \"YYYY-MM-DDHH:mm\", this.Timezone);\n                result.push({\n                    open,\n                    close,\n                });\n            }\n            return result;\n        });\n    }\n}\n\nmodule.exports = Efteling;"]}