{"version":3,"sources":["../lib/geoLocation.js"],"names":["s_longitude","Symbol","s_latitude","GeoLocation","longitude","latitude","parseFloat","undefined","Error","Math","max","min","Latitude","Longitude","LatitudeRaw","LongitudeRaw","formatNumberToGeoLocation","locationA","locationB","random","number","locationMinutes","floor","locationSeconds","toFixed","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAIA,cAAcC,QAAlB;AACA,IAAIC,aAAaD,QAAjB;;AAEA;;;;;IAIME,W;AACF;;;;;AAKA,+BAGG;AAAA,kCAFCC,SAED;AAAA,YAFCA,SAED,kCAFa,CAEb;AAAA,iCADCC,QACD;AAAA,YADCA,QACD,iCADY,CACZ;;AAAA;;AACC,aAAKL,WAAL,IAAoBM,WAAWF,SAAX,CAApB;AACA,aAAKF,UAAL,IAAmBI,WAAWD,QAAX,CAAnB;;AAEA;AACA,YAAI,KAAKL,WAAL,MAAsBO,SAAtB,IAAmC,OAAO,KAAKP,WAAL,CAAP,IAA6B,QAApE,EAA8E;AAC1E,kBAAM,IAAIQ,KAAJ,CAAU,4CAA4C,KAAKR,WAAL,CAAtD,CAAN;AACH;AACD,YAAI,KAAKE,UAAL,MAAqBK,SAArB,IAAkC,OAAO,KAAKL,UAAL,CAAP,IAA4B,QAAlE,EAA4E;AACxE,kBAAM,IAAIM,KAAJ,CAAU,2CAA2C,KAAKN,UAAL,CAArD,CAAN;AACH;;AAED;AACA;AACA,aAAKF,WAAL,IAAoB,KAAKA,WAAL,IAAoB,GAAxC;AACA,YAAI,KAAKA,WAAL,IAAoB,GAAxB,EAA6B,KAAKA,WAAL,KAAqB,GAArB;;AAE7B;AACA,aAAKE,UAAL,IAAmBO,KAAKC,GAAL,CAAS,CAAC,EAAV,EAAcD,KAAKE,GAAL,CAAS,KAAKT,UAAL,CAAT,EAA2B,EAA3B,CAAd,CAAnB;AACH;;AAED;;;;;;;;;;;AA0CA;;;;mCAIW;AACP,yBAAW,KAAKU,QAAhB,UAA6B,KAAKC,SAAlC;AACH;;AAED;;;;;;;uCAIe;AACX,mBAAO,gCAAgC,KAAKC,WAArC,GAAmD,GAAnD,GAAyD,KAAKC,YAArE;AACH;;AAED;;;;;;;4BArDgB;AACZ,gBAAI,KAAKf,WAAL,IAAoB,CAAxB,EAA2B;AACvB,uBAAOgB,0BAA0B,CAAC,KAAKhB,WAAL,CAA3B,IAAgD,GAAvD;AACH,aAFD,MAEO;AACH,uBAAOgB,0BAA0B,KAAKhB,WAAL,CAA1B,IAA+C,GAAtD;AACH;AACJ;;AAED;;;;;;;4BAImB;AACf,mBAAO,KAAKA,WAAL,CAAP;AACH;;AAED;;;;;;;;4BAKe;AACX,gBAAI,KAAKE,UAAL,IAAmB,CAAvB,EAA0B;AACtB,uBAAOc,0BAA0B,CAAC,KAAKd,UAAL,CAA3B,IAA+C,GAAtD;AACH,aAFD,MAEO;AACH,uBAAOc,0BAA0B,KAAKd,UAAL,CAA1B,IAA8C,GAArD;AACH;AACJ;;AAED;;;;;;;4BAIkB;AACd,mBAAO,KAAKA,UAAL,CAAP;AACH;;;sCAsBoBe,S,EAAWC,S,EAAW;AACvC,mBAAO,IAAIf,WAAJ,CAAgB;AACnBC,2BAAWa,UAAUF,YAAV,GAA0BN,KAAKU,MAAL,MAAiBD,UAAUH,YAAV,GAAyBE,UAAUF,YAApD,CADlB;AAEnBV,0BAAUY,UAAUH,WAAV,GAAyBL,KAAKU,MAAL,MAAiBD,UAAUJ,WAAV,GAAwBG,UAAUH,WAAnD;AAFhB,aAAhB,CAAP;AAIH;;;;;;AAGL;;;;;;;AAKA,SAASE,yBAAT,CAAmCI,MAAnC,EAA2C;AACvC;AACA,QAAIC,kBAAkBZ,KAAKa,KAAL,CAAYF,SAAS,CAAV,GAAe,EAA1B,CAAtB;AACA,QAAIG,kBAAkB,CAAGH,SAAS,EAAV,GAAgB,CAAjB,GAAsB,EAAvB,EAA2BI,OAA3B,CAAmC,CAAnC,CAAtB;;AAEA;AACA,WAAUf,KAAKa,KAAL,CAAWF,MAAX,CAAV,YAAqCC,eAArC,cAA6DE,eAA7D;AACH;;AAEDE,OAAOC,OAAP,GAAiBvB,WAAjB","file":"geoLocation.js","sourcesContent":["\"use strict\";\n\nvar s_longitude = Symbol();\nvar s_latitude = Symbol();\n\n/**\n * GeoLocation class to store theme park locations and supply helper functions\n * @class\n */\nclass GeoLocation {\n    /**\n     * @param {Object} location\n     * @param {Number} location.longitude - New location's longitude\n     * @param {Number} location.latitude - New location's latitude\n     * */\n    constructor({\n        longitude = 0,\n        latitude = 0\n    }) {\n        this[s_longitude] = parseFloat(longitude);\n        this[s_latitude] = parseFloat(latitude);\n\n        // validate longitude and latitude\n        if (this[s_longitude] === undefined || typeof(this[s_longitude]) != \"number\") {\n            throw new Error(\"Invalid/Undefined value for longitude: \" + this[s_longitude]);\n        }\n        if (this[s_latitude] === undefined || typeof(this[s_latitude]) != \"number\") {\n            throw new Error(\"Invalid/Undefined value for latitude: \" + this[s_latitude]);\n        }\n\n        // wrap longitude and latitude around so they are in a standard format for us to use\n        //  longitude should be between -180,180\n        this[s_longitude] = this[s_longitude] % 360;\n        if (this[s_longitude] > 180) this[s_longitude] -= 360;\n\n        //  latitude should be clamped between -90,90 (if we go too far north, we don't want to wrap around to the south)\n        this[s_latitude] = Math.max(-90, Math.min(this[s_latitude], 90));\n    }\n\n    /**\n     * Return the formatted longitude for this location\n     * Formatted as XX°YY′ZZ″\n     * @type {String}\n     * */\n    get Longitude() {\n        if (this[s_longitude] < 0) {\n            return formatNumberToGeoLocation(-this[s_longitude]) + \"W\";\n        } else {\n            return formatNumberToGeoLocation(this[s_longitude]) + \"E\";\n        }\n    }\n\n    /**\n     * Return the raw numeric value of this position's longitude\n     * @type {Number}\n     * */\n    get LongitudeRaw() {\n        return this[s_longitude];\n    }\n\n    /**\n     * Return the formatted latitude for this location\n     * Formatted as XX°YY′\n     * @type {String}\n     * */\n    get Latitude() {\n        if (this[s_latitude] < 0) {\n            return formatNumberToGeoLocation(-this[s_latitude]) + \"S\";\n        } else {\n            return formatNumberToGeoLocation(this[s_latitude]) + \"N\";\n        }\n    }\n\n    /**\n     * Return the raw numeric value of this position's latitude\n     * @type {Number}\n     * */\n    get LatitudeRaw() {\n        return this[s_latitude];\n    }\n\n    /**\n     * Return this GeoLocation safe for printing\n     * @returns {String} Location String formatted as: ([latitude], [longitude])\n     * */\n    toString() {\n        return `(${this.Latitude}, ${this.Longitude})`;\n    }\n\n    /**\n     * Return a URL to this park on Google Maps\n     * @returns {String} URL to this park on Google Maps\n     * */\n    toGoogleMaps() {\n        return \"http://maps.google.com/?ll=\" + this.LatitudeRaw + \",\" + this.LongitudeRaw;\n    }\n\n    /**\n     * Return a random point between two GeoLocation objects\n     * @returns {GeoLocation} New GeoLocation object randomly set between locationA and locationB\n     */\n    static RandomBetween(locationA, locationB) {\n        return new GeoLocation({\n            longitude: locationA.LongitudeRaw + (Math.random() * (locationB.LongitudeRaw - locationA.LongitudeRaw)),\n            latitude: locationA.LatitudeRaw + (Math.random() * (locationB.LatitudeRaw - locationA.LatitudeRaw)),\n        });\n    }\n}\n\n/**\n * Format a decimal number to [Int]\\u00B0 [Remainder]\\u2032\n * @private\n * @returns {String} Formatted string representing this number in XX° YY′ ZZ″\n * */\nfunction formatNumberToGeoLocation(number) {\n    // work out minutes and seconds for this input\n    var locationMinutes = Math.floor((number % 1) * 60);\n    var locationSeconds = (((number * 60) % 1) * 60).toFixed(2);\n\n    // return formatted string\n    return `${Math.floor(number)}\\u00B0${locationMinutes}\\u2032${locationSeconds}\\u2033`;\n}\n\nmodule.exports = GeoLocation;"]}