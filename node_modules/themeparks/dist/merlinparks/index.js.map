{"version":3,"sources":["../../lib/merlinparks/index.js"],"names":["Park","require","Moment","uuid","unzip","s_apiKey","Symbol","s_apiBase","s_calendarURLBase","s_appVersion","s_appBuild","s_deviceID","s_dataVersion","s_deviceTokenCacheTime","s_userIDCacheTime","s_dataCacheTime","MerlinPark","options","name","useragent","api_key","Error","initial_data_version","app_build","app_version","device_id","api_base","calendar_base","device_token_cachetime","user_id_cachetime","data_cachetime","GetParkData","then","rideNames","MakeAPICall","url","APIBase","data","i","ride","entities","Item","records","rideObject","GetRideObject","id","_id","Log","WaitTime","IsOpen","QueueTime","Promise","resolve","Cache","Wrap","GenerateUserID","user_id","HTTP","method","user_identifier","device_identifier","headers","token","reject","newUserID","FetchParkData","DataVersion","rideData","item","Name","version","returnFullResponse","response","statusCode","fromBuffer","body","lazyEntries","err","zip","manifestData","recordsData","GetNextEntry","catch","readEntry","on","file","fileName","ReadZipFile","RegisterDevice","json","calendarData","parkDates","Type","times","OpeningHours","Open","result","timeRange","range","startDate","From","endDate","To","exec","replace","openingTime","closingTime","Schedule","SetRange","module","exports","openReadStream","readStream","chunk","JSON","parse","e"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\n\n// include core Park class\nconst Park = require(\"../park\");\nconst Moment = require(\"moment-timezone\");\n\n// uuid generation lib\nconst uuid = require(\"uuid/v4\");\n// zip lib to extract data\nconst unzip = require(\"yauzl\");\n\nconst s_apiKey = Symbol();\nconst s_apiBase = Symbol();\nconst s_calendarURLBase = Symbol();\nconst s_appVersion = Symbol();\nconst s_appBuild = Symbol();\nconst s_deviceID = Symbol();\nconst s_dataVersion = Symbol();\n\nconst s_deviceTokenCacheTime = Symbol();\nconst s_userIDCacheTime = Symbol();\nconst s_dataCacheTime = Symbol();\n\n/**\n * Implements the Merlin Park API framework. Thorpe Park, Alton Towers, Chessington etc. use this API framework\n * @class\n * @extends Park\n */\nclass MerlinPark extends Park {\n    /**\n     * Create new Merlin Object.\n     * This object should not be called directly, but rather extended for each of the individual Merlin parks\n     * @param {Object} options\n     * @param {String} options.api_key API key to access this park's API\n     * @param {String} [options.api_base] API Base to use when accessing the API\n     * @param {String} [options.app_build] Build version of the app (optional)\n     * @param {String} [options.app_version] App version of the app (optional)\n     * @param {String} [options.device_id] Device identifier for use against the API (optional)\n     * @param {String} [options.initial_data_version] The initial version timestamp to fetch (optional)\n     * @param {Number} [options.device_token_cachetime=86400000] Time to cache device token, in milliseconds (optional)\n     * @param {Number} [options.user_id_cachetime=43200000] Time to cache user ID, in milliseconds (optional)\n     * @param {Number} [options.data_cachetime=43200000] Time to ride data, in milliseconds (optional)\n     */\n    constructor(options = {}) {\n        options.name = options.name || \"Merlin Park\";\n\n        // hard-code UserAgent for these parks\n        //  do this before calling super, so we don't get a randomly generated one\n        options.useragent = \"okhttp/3.2.0\";\n\n        // inherit from base class\n        super(options);\n\n        // custom API options\n        if (!options.api_key) throw new Error(\"Merlin Parks require an API key\");\n        this[s_apiKey] = options.api_key;\n        if (!options.initial_data_version) throw new Error(\"Merlin Parks require an initial data version to fetch ride names\");\n        this[s_dataVersion] = options.initial_data_version;\n\n        // app version options (optionally overriden)\n        this[s_appBuild] = options.app_build || \"5\";\n        this[s_appVersion] = options.app_version || \"1.0.1\";\n        this[s_deviceID] = options.device_id || \"123\";\n\n        // default base API\n        this[s_apiBase] = options.api_base || \"https://api.attractions.io/v1/\";\n        this[s_calendarURLBase] = options.calendar_base || \"https://www.thorpepark.com/\";\n\n        // cache times\n        this[s_deviceTokenCacheTime] = options.device_token_cachetime || 86400000; // default: 24 hours\n        this[s_userIDCacheTime] = options.user_id_cachetime || 43200000; // default: 12 hours\n        this[s_dataCacheTime] = options.data_cachetime || 43200000; // default: 12 hours\n    }\n\n    /**\n     * Get the API Base URL\n     */\n    get APIBase() {\n        return this[s_apiBase];\n    }\n\n    FetchWaitTimes() {\n        // first, make sure we have our park data (ride names etc.)\n        return this.GetParkData().then((rideNames) => {\n            // fetch wait times\n            return this.MakeAPICall({\n                url: `${this.APIBase}live-data`\n            }).then((data) => {\n                for (var i = 0, ride; ride = data.entities.Item.records[i++];) {\n                    // apply each wait time data\n                    var rideObject = this.GetRideObject({\n                        id: ride._id,\n                        name: rideNames[ride._id],\n                    });\n\n                    if (!rideObject) {\n                        this.Log(`Failed to find ride with ID ${ride.id}`);\n                    } else {\n                        // update ride wait time (wait times are in seconds in this API!)\n                        rideObject.WaitTime = ride.IsOpen ? (ride.QueueTime / 60) : -1;\n                    }\n                }\n\n                return Promise.resolve();\n            });\n        });\n    }\n\n    /**\n     * Get an API token from cache or through registering a new device\n     */\n    RegisterDevice() {\n        // fetch new device token if we haven't already got one in our cache\n        return this.Cache.Wrap(\"device_token\", () => {\n            // first, get (or generate) a new user ID\n            return this.GenerateUserID().then((user_id) => {\n                // request token for further API requests\n                return this.HTTP({\n                    url: `${this[s_apiBase]}installation`,\n                    method: \"POST\",\n                    data: {\n                        user_identifier: user_id,\n                        device_identifier: this[s_deviceID],\n                        app_version: this[s_appVersion],\n                        app_build: this[s_appBuild]\n                    },\n                    headers: {\n                        \"occasio-platform\": \"Android\",\n                        \"occasio-platform-version\": \"6.0.1\",\n                        \"occasio-app-build\": this[s_appBuild],\n                        \"authorization\": `Attractions-Io api-key \"${this[s_apiKey]}\"`,\n                    }\n                }).then((data) => {\n                    if (data && data.token) {\n                        return Promise.resolve(data.token);\n                    }\n\n                    return Promise.reject(\"No data returned\");\n                });\n            });\n        }, this[s_deviceTokenCacheTime]);\n    }\n\n    /**\n     * Generate (or fetch a cached) user ID\n     */\n    GenerateUserID() {\n        return this.Cache.Wrap(\"user_id\", () => {\n            // generate new UUID if cache hit fails\n            const newUserID = uuid();\n\n            this.Log(`Generated new UserID ${newUserID}`);\n\n            return Promise.resolve(newUserID);\n        }, this[s_userIDCacheTime]);\n    }\n\n    /**\n     * Get (or fetch new) park data\n     */\n    GetParkData() {\n        return this.Cache.Wrap(\"data\", () => {\n            // fetch fresh/updated data\n            return this.FetchParkData(this.DataVersion).then((data) => {\n                var rideData = {};\n                for (var i = 0, item; item = data.Item[i++];) {\n                    rideData[item._id] = item.Name;\n                }\n                return Promise.resolve(rideData);\n            });\n        }, this[s_dataCacheTime]);\n    }\n\n    /**\n     * Get the latest data version timestamp\n     */\n    get DataVersion() {\n        return this[s_dataVersion];\n    }\n\n    /**\n     * Fetch/Sync park data\n     * Warning: full sync is ~30MB\n     */\n    FetchParkData(version) {\n        // this is a recursive function, and will keep fetching data until we get no more deltas to resolve\n        //  note: we should attempt to periodically update the initialVersion to cut down on these requests\n\n        // remember this as the latest version for next fetch\n        this[s_dataVersion] = version;\n\n        // Fetch data\n        return this.MakeAPICall({\n            url: `${this[s_apiBase]}data`,\n            data: {\n                version: version\n            },\n            // we want the full response to get the status code\n            returnFullResponse: true,\n        }).then((response) => {\n            if (response.statusCode == 304) {\n                // reject\n                this.Log(`Reached status 304 accessing data version ${version}`);\n                return Promise.reject();\n            } else {\n                this.Log(`Received data for version ${version}`);\n\n                return new Promise((resolve, reject) => {\n                    // unzip data\n                    unzip.fromBuffer(response.body, {\n                        lazyEntries: true\n                    }, (err, zip) => {\n                        var manifestData;\n                        var recordsData;\n\n                        this.Log(\"Parsing zip file\");\n                        if (err) {\n                            return reject(err);\n                        }\n\n                        const GetNextEntry = () => {\n                            if (manifestData && recordsData) {\n                                // got both the files we need, stop reading the zip file\n\n                                // fetch next data URL\n                                if (manifestData.version) {\n                                    this.FetchParkData(manifestData.version).catch(() => {\n                                        // as soon as we hit an error, return the current level or records data\n                                        return resolve(recordsData);\n                                    });\n                                } else {\n                                    return resolve(recordsData);\n                                }\n                            } else {\n                                // read next entry\n                                zip.readEntry();\n                            }\n                        };\n\n                        zip.on(\"entry\", (file) => {\n                            this.Log(`Got zip file ${file.fileName}`);\n\n                            // look for the two files we want\n                            if (file.fileName == \"manifest.json\") {\n                                ReadZipFile(zip, file).then((data) => {\n                                    manifestData = data;\n\n                                    GetNextEntry();\n                                });\n                            } else if (file.fileName == \"records.json\") {\n                                ReadZipFile(zip, file).then((data) => {\n                                    recordsData = data;\n\n                                    GetNextEntry();\n                                });\n                            } else {\n                                GetNextEntry();\n                            }\n                        });\n\n                        // start reading file...\n                        zip.readEntry();\n                    });\n                });\n            }\n        });\n    }\n\n    /**\n     * Generic API request function, will sort out API token and send auth headers\n     * @param {*} options \n     * @param {String} options.url URL to access\n     * @param {String} [options.method=GET] method to use\n     * @param {Object} [options.data={}] data/query string to use\n     */\n    MakeAPICall(options = {\n        method: \"GET\",\n        data: {}\n    }) {\n        // get token\n        return this.RegisterDevice().then((token) => {\n            // inject auth headers into request headers\n            if (!options.headers) {\n                options.headers = {};\n            }\n            options.headers[\"occasio-platform\"] = \"Android\";\n            options.headers[\"occasio-platform-version\"] = \"6.0.1\";\n            options.headers[\"occasio-app-build\"] = this[s_appBuild];\n            options.headers[\"authorization\"] = `Attractions-Io api-key \"${this[s_apiKey]}\", installation-token=\"${token}\"`;\n\n            // make API call\n            return this.HTTP(options);\n        });\n    }\n\n    FetchOpeningTimes() {\n        return new Promise((resolve, reject) => {\n            this.HTTP({\n                url: `${this[s_calendarURLBase]}Umbraco/Api/Calendar/GetAllOpeningTimes`,\n                method: \"GET\",\n                headers: {\n                    \"Referer\": this[s_calendarURLBase],\n                    \"X-Requested-With\": \"XMLHttpRequest\",\n                },\n                json: true\n            }).then((calendarData) => {\n                // find theme park dates from response\n                //  it contains \"WatterPark\"[sic] times as well in a separate array\n                var parkDates = null;\n                if (calendarData[0] && calendarData[0].Type) {\n                    // for resorts with multiple parks (Alton Towers)\n                    for (var i = 0, times; times = calendarData[i++];) {\n                        if (times.Type == \"ThemePark\") {\n                            parkDates = times.OpeningHours;\n                            break;\n                        }\n                    }\n                } else if (calendarData[0].Open) {\n                    // resorts with only 1 park (Thorpe Park)\n                    parkDates = calendarData;\n                } else {\n                    return reject(\"Invalid/Unknown calendar data returned\");\n                }\n\n                var result, timeRange;\n                for (i = 0, timeRange; timeRange = parkDates[i++];) {\n                    var range = {\n                        startDate: Moment(timeRange.From, \"YYYY-MM-DDTHH:mm:ss\"),\n                        endDate: Moment(timeRange.To, \"YYYY-MM-DDTHH:mm:ss\")\n                    };\n\n                    this.Log(`Processing ${range.startDate} => ${range.endDate}`);\n\n                    // figure out opening times for this range\n                    if (result = /([0-9:]+\\s?[ap]m)\\s*-\\s*([0-9:]+\\s?[ap]m)/gi.exec(timeRange.Open.replace(/\\./g, \":\"))) {\n                        range.openingTime = Moment(result[1].replace(/ /g, \"\"), \"HH:mma\");\n                        range.closingTime = Moment(result[2].replace(/ /g, \"\"), \"HH:mma\");\n                    }\n                    // try shorthand format too, in case someone entered the times in badly\n                    else if (result = /([0-9]+)\\s*-\\s*([0-9]+)/gi.exec(timeRange.Open.replace(/\\./g, \":\"))) {\n                        range.openingTime = Moment(result[1] + \":00am\", \"HH:mma\");\n                        range.closingTime = Moment(result[2] + \":00pm\", \"HH:mma\");\n                    } else {\n                        this.Log(`Unable to understand hour format: ${timeRange.Open}`);\n                        continue;\n                    }\n\n                    // apply this range\n                    this.Schedule.SetRange(range);\n                }\n\n                resolve();\n            }, reject);\n        });\n    }\n}\n\n// export the class\nmodule.exports = MerlinPark;\n\n// static functions\nfunction ReadZipFile(zip, file) {\n    return new Promise((resolve, reject) => {\n        var data = \"\";\n        zip.openReadStream(file, function(err, readStream) {\n            if (err) {\n                return reject(err);\n            }\n\n            readStream.on(\"data\", function(chunk) {\n                data += chunk;\n            }).on(\"end\", function() {\n                // parse JSON data\n                try {\n                    data = JSON.parse(data);\n                    return resolve(data);\n                } catch (e) {\n                    return reject(`JSON parse error extracting ${file.fileName}: ${e}`);\n                }\n            });\n        });\n    });\n}"]}