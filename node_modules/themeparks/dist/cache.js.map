{"version":3,"sources":["../lib/cache.js"],"names":["Settings","require","s_prefix","Symbol","Cache","options","prefix","key","GetGlobal","Prefix","Promise","resolve","reject","get","err","result","undefined","data","SetGlobal","set","setFunction","ttl","_Wrap","bind","Get","Set","_cacheGetter","_cacheSetter","then","dataToCache","module","exports"],"mappings":"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","file":"cache.js","sourcesContent":["/**\n * Very simple wrapper around node-cache-manager\n */\n\nconst Settings = require(\"./settings\");\n\nconst s_prefix = Symbol();\n\nclass Cache {\n    /**\n     * Create Cache object\n     * This object will handle caching data for later use\n     * @param {Object} [options]\n     * @param {String} [options.prefix] Preface to prepend to all cache keys for this instance\n     */\n    constructor(options = {}) {\n        // setup cache configuration\n        this[s_prefix] = options.prefix || \"\";\n    }\n\n    /**\n     * Get the prefix used for this caching instance\n     * @returns {String} Cache key prefix\n     */\n    get Prefix() {\n        return this[s_prefix] + \"_\";\n    }\n\n    /** \n     * Get a cached value\n     * @param {String} key Key to request associated data for \n     * @returns {Promise<Object>} Returns Promise resolved if data found, rejects if data is not in cache\n     */\n    Get(key) {\n        // prepend our key to restrict our request to our park's cache (avoid conflicts with other APIs)\n        return this.GetGlobal(this.Prefix + key);\n    }\n\n    /**\n     * Get a globally cached value\n     * This is identical to Get, but the requested key will be in scope of the entire library, not just the park that requests the data\n     * @param {String} key Key to request associated data for \n     * @returns {Promise<Object>} Returns Promise resolved if data found, rejects if data is not in cache\n     */\n    GetGlobal(key) {\n        return new Promise((resolve, reject) => {\n            // prepend the prefix to the requested key\n            Settings.Cache.get(\"themeparks_\" + key, (err, result) => {\n                // reject promise on failure\n                if (err) return reject(err);\n                // reject on no data returned\n                if (result === undefined || result === null) return reject();\n\n                // resolve promise on successful data\n                return resolve(result);\n            });\n        });\n    }\n\n    /**\n     * Set a cached value\n     * @param {String} key Key to set data for\n     * @param {Object} data Data to store in cache\n     * @param {Object} [options] Additional options for caching (see node-cache-manager)\n     * @returns {Promise} Returns Promise resolving if cached data was successfully set\n     */\n    Set(key, data, options = {}) {\n        // add our prefix and pass onto the SetGlobal function\n        return this.SetGlobal(this.Prefix + key, data, options);\n    }\n\n    /**\n     * Set a cached value library-wide\n     * Idential to Set, but cached at a library level instead of for the owning park\n     * @param {String} key Key to set data for\n     * @param {Object} data Data to store in cache\n     * @param {Object} [options] Additional options for caching (see node-cache-manager)\n     * @returns {Promise} Returns Promise resolving if cached data was successfully set\n     */\n    SetGlobal(key, data, options = {}) {\n        return new Promise((resolve, reject) => {\n            // prepend prefix to key setting\n            Settings.Cache.set(\"themeparks_\" + key, data, options, (err) => {\n                // if failure, reject Promise\n                if (err) return reject(err);\n\n                // other, resolve\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Wrap a get request and pass a setter to tidy up the usual get/set boilerplate\n     * @param {String} key Key to get/set\n     * @param {Function} setFunction Function to set data if it is missing from the cache. setFunction should return a Promise\n     * @param {Number|Function} [ttl] How long cached result should last. Can be a number (seconds) or a function that will return a value\n     */\n    Wrap(key, setFunction, ttl) {\n        return _Wrap.bind(this)(key, setFunction, this.Get, this.Set, ttl);\n    }\n\n    /**\n     * Wrap a get request and pass a setter to tidy up the usual get/set boilerplate. This version sits in the global scope, rather than per-park.\n     * @param {String} key Key to get/set\n     * @param {Function} setFunction Function to set data if it is missing from the cache. setFunction should return a Promise\n     * @param {Number|Function} [ttl] How long cached result should last. Can be a number (seconds) or a function that will return a value\n     */\n    WrapGlobal(key, setFunction, ttl) {\n        return _Wrap.bind(this)(key, setFunction, this.GetGlobal, this.SetGlobal, ttl);\n    }\n}\n\n// Internal wrap helper to not copy/paste logic for global and local-scope wraps\nfunction _Wrap(key, setFunction, _cacheGetter, _cacheSetter, ttl) {\n    return new Promise((resolve, reject) => {\n        // attempt to get the requested key (note, no prefix here, it's attached in the Get function)\n        //  pass success directly through to resolve\n        _cacheGetter.bind(this)(key).then(resolve, () => {\n            // if cache miss, call the setFunction to get the new value we want\n            setFunction().then((dataToCache) => {\n                // work out ttl\n                var options = {};\n                if (ttl) {\n                    //  if it's a function, call the function to get the required ttl\n                    if (typeof ttl == \"function\") {\n                        ttl = ttl();\n                    }\n                    options.ttl = ttl;\n                }\n\n                // store in cache\n                _cacheSetter.bind(this)(key, dataToCache, options).then(() => {\n                    // resolve with newly cached data\n                    resolve(dataToCache);\n                }, reject);\n            }, reject);\n        });\n    });\n}\n\n// create new cache object and export it\nmodule.exports = Cache;"]}