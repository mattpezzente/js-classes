{"version":3,"sources":["../lib/schedule.js"],"names":["Log","require","moment","settings","s_scheduleDates","Symbol","s_scheduleDatesSpecial","s_scheduleDateFormat","s_scheduleTimeFormat","s_scheduleIsDirty","Schedule","dateFormat","timeFormat","Map","DefaultDateFormat","DefaultTimeFormat","dates","datesSpecial","scheduleData","date","openingTime","closingTime","specialHours","type","parseDateTime","startOf","endOf","day","dateToDay","todaySet","year","month","set","isBefore","add","newScheduleData","format","has","checkDirtyObj","get","IsDirty","newSpecialScheduleData","newDataStringified","JSON","stringify","specialDayArray","i","checkData","push","startDate","endDate","retValue","m","isSameOrBefore","SetDate","dayData","returnObject","special","returnArray","dateSchedule","GetDate","value","dateObject","varName","isMoment","newDate","ISO_8601","isValid","Math","floor","unix","utcOffset","module","exports"],"mappings":"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","file":"schedule.js","sourcesContent":["\"use strict\";\n\nvar Log = require(\"./debugPrint\");\nvar moment = require(\"moment-timezone\");\nvar settings = require(\"./settings\");\n\nvar s_scheduleDates = Symbol();\nvar s_scheduleDatesSpecial = Symbol();\nvar s_scheduleDateFormat = Symbol();\nvar s_scheduleTimeFormat = Symbol();\nvar s_scheduleIsDirty = Symbol();\n\n/**\n * @typedef ScheduleData\n * @type Object\n * @property {String} date Date this schedule data applies to (formatted by DateFormat)\n * @property {String} openingTime Opening time for this date (formatted by TimeFormat)\n * @property {String} closingTime Closing time for this date (formatted by TimeFormat)\n * @property {String} type Whether this schedule data refers to an \"Operating\", \"Closed\" or \"Refurbishment\" status\n * @property {SpecialScheduleData[]} special Won't exist if no special times exist for this date\n */\n\n/**\n * @typedef SpecialScheduleData\n * @type Object\n * @property {String} openingTime Opening time for this special schedule data (formatted by TimeFormat)\n * @property {String} closingTime Closing time for this special schedule data (formatted by TimeFormat)\n * @property {String} type Type of special schedule this is (eg. \"Extra Magic Hours\")\n */\n\n/**\n * Schedule class to hold opening and closing times for parks and rides etc.\n * Supports standard and \"special\" opening times\n * @class\n */\nclass Schedule {\n    /**\n     * Create a new Schedule object\n     * @param {Object} scheduleConfig\n     * @param {String} [scheduleConfig.dateFormat] Moment.js compatible format string to return dates as. See http://momentjs.com/docs/#/displaying/format/\n     * @param {String} [scheduleConfig.timeFormat] Moment.js compatible format string to return times as. See http://momentjs.com/docs/#/displaying/format/\n     */\n    constructor({\n        dateFormat = null,\n        timeFormat = null,\n    } = {}) {\n        // use Map for better structure (int -> data)\n        //  int is the number of days since Unix Epoch\n        this[s_scheduleDates] = new Map();\n        // also one for special hours (this is actually int -> data[] to support multiple special times)\n        this[s_scheduleDatesSpecial] = new Map();\n        // this schedule's date print format\n        this[s_scheduleDateFormat] = dateFormat || settings.DefaultDateFormat;\n        // this schedule's time print format\n        this[s_scheduleTimeFormat] = timeFormat || settings.DefaultTimeFormat;\n\n        // initially, our data is empty, so not really dirty (we don't want to save empty data by mistake)\n        this[s_scheduleIsDirty] = false;\n    }\n\n    /**\n     * Write schedule data to a JSON object\n     * @returns {Object} Current schedule data\n     */\n    toJSON() {\n        return {\n            dates: this[s_scheduleDates],\n            datesSpecial: this[s_scheduleDatesSpecial],\n        };\n    }\n\n    /**\n     * Restore schedule data state from a JSON object\n     * @param {Object} Object from toJSON to restore data from\n     */\n    fromJSON(scheduleData) {\n        this[s_scheduleDates] = scheduleData.dates;\n        this[s_scheduleDatesSpecial] = scheduleData.datesSpecial;\n    }\n\n    /**\n     * Whether the data needs to be cached\n     * @type {Boolean}\n     */\n    get IsDirty() {\n        return this[s_scheduleIsDirty];\n    }\n\n    /**\n     * Set the data as dirty\n     */\n    // TODO - bring this as a private property and make schedules handle their own caching\n    set IsDirty(value) {\n        this[s_scheduleIsDirty] = value;\n    }\n\n    /**\n     * Set schedule data for a date\n     * @param {Object} scheduleData\n     * @param {Moment|String} [scheduleData.date=scheduleData.openingTime] Moment.js date object (or a valid date String to be parsed by Moment JS). Will use openingTime if this is not supplied\n     * @param {Moment|String} [scheduleData.openingTime] Moment.js date object of this day's opening time (or a valid date String to be parsed by Moment JS) (can be ignored if type is Closed)\n     * @param {Moment|String} [scheduleData.closingTime] Moment.js date object of this day's closing time (or a valid date String to be parsed by Moment JS) (can be ignored if type is Closed)\n     * @param {Boolean} [scheduleData.specialHours=false] Is this schedule data part of schedule special hours?\n     * @param {String} [scheduleData.type=Operating] The schedule type. Normal schedules should always be \"Operating\", \"Closed\" or \"Refurbishment\". Special schedules can be any String (eg. Extra Magic Hours).\n     * @returns {Boolean} success Returns true if the operation was a success and the data was actually changed\n     */\n    SetDate({\n        // the day to set the schedule data for\n        date = null,\n        // opening time for this day\n        openingTime = null,\n        // closing time for this day\n        closingTime = null,\n        // is this special hours data? (default: false)\n        specialHours = false,\n        // the type of this schedule date (default: Operating)\n        type = \"Operating\"\n    }) {\n        // if we haven't been supplied a date, use the opening time\n        if (!date) date = openingTime;\n\n        // check our date is a valid momentjs object\n        date = parseDateTime(date, \"date\");\n\n        // special case, if this is a closed date, support not passing in opening and closing times\n        if (type == \"Closed\") {\n            if (!openingTime) openingTime = date.startOf(\"day\");\n            if (!closingTime) closingTime = date.endOf(\"day\");\n        }\n\n        openingTime = parseDateTime(openingTime, \"openingTime\");\n        closingTime = parseDateTime(closingTime, \"closingTime\");\n\n        // if any of our dates are invalid, return false\n        if (!date || !openingTime || !closingTime) return false;\n\n        // calculate the days since Unix Epoch\n        var day = dateToDay(date);\n\n        // make sure opening and closing times are in the correct day!\n        var todaySet = {\n            \"year\": date.year(),\n            \"month\": date.month(),\n            \"date\": date.date()\n        };\n        openingTime.set(todaySet);\n        closingTime.set(todaySet);\n\n        // work out if the closing time is in the following day\n        if (closingTime.isBefore(openingTime)) {\n            // add 1 day if the closing time comes before the opening time (implying it's open past midnight!)\n            closingTime.add(1, \"day\");\n        }\n\n        // build schedule data object and add it to our schedule map\n        if (!specialHours) {\n            // check our schedule type is sane\n            if (type != \"Operating\" && type != \"Closed\" && type != \"Refurbishment\") {\n                Log(`Tried to use invalid schedule type ${type} for standard schedule data (must be Operating, Closed or Refurbishment)`);\n                return false;\n            }\n\n            var newScheduleData = {\n                \"date\": date.format(this[s_scheduleDateFormat]),\n                \"openingTime\": openingTime.format(this[s_scheduleTimeFormat]),\n                \"closingTime\": closingTime.format(this[s_scheduleTimeFormat]),\n                \"type\": type\n            };\n\n            // check if we already have this data for this day (don't invalidate cache etc if it hasn't changed)\n            if (this[s_scheduleDates].has(day)) {\n                var checkDirtyObj = this[s_scheduleDates].get(day);\n                if (\n                    checkDirtyObj.date == newScheduleData.date &&\n                    checkDirtyObj.openingTime == newScheduleData.openingTime &&\n                    checkDirtyObj.closingTime == newScheduleData.closingTime &&\n                    checkDirtyObj.type == newScheduleData.type) {\n                    // data is identical to existing object, don't update\n                    return false;\n                }\n            }\n\n            // set this day's schedule data\n            this[s_scheduleDates].set(day, newScheduleData);\n\n            // we have new data, so mark it as dirty to get cached\n            this.IsDirty = true;\n        } else {\n            // special hours can't be Operating or Closed, that is for normal hours\n            if (type == \"Operating\" || type == \"Closed\") {\n                Log(`Tried to use invalid schedule type ${type} for special schedule data (can't be Operating or Closed)`);\n                return false;\n            }\n\n            // add a new special hours array if we don't already have one\n            if (!this[s_scheduleDatesSpecial].has(day)) {\n                this[s_scheduleDatesSpecial].set(day, []);\n\n                // we have new data, so mark it as dirty to get cached\n                this.IsDirty = true;\n            }\n\n            var newSpecialScheduleData = {\n                \"openingTime\": openingTime.format(this[s_scheduleTimeFormat]),\n                \"closingTime\": closingTime.format(this[s_scheduleTimeFormat]),\n                \"type\": type\n            };\n\n            // check we don't already have this special data in our array\n            var newDataStringified = JSON.stringify(newSpecialScheduleData);\n            var specialDayArray = this[s_scheduleDatesSpecial].get(day);\n            for (var i = 0, checkData; checkData = specialDayArray[i++];) {\n                if (JSON.stringify(checkData) == newDataStringified) {\n                    // this object already exists, so bail out\n                    return false;\n                }\n            }\n\n            // add our new data to the specials array\n            specialDayArray.push(newSpecialScheduleData);\n\n            // we have new data, so mark it as dirty to get cached\n            this.IsDirty = true;\n        }\n\n        return true;\n    }\n\n    /**\n     * Set a range of dates with the same schedule data\n     * @param {Object} scheduleData\n     * @param {Moment|String} scheduleData.startDate Moment.js date object to start schedule date range (or a valid date String to be parsed by Moment JS)\n     * @param {Moment|String} scheduleData.endDate Moment.js date object to end schedule date range (or a valid date String to be parsed by Moment JS)\n     * @param {Moment|String} scheduleData.openingTime Moment.js date object of this day's opening time (or a valid date String to be parsed by Moment JS)\n     * @param {Moment|String} scheduleData.closingTime Moment.js date object of this day's closing time (or a valid date String to be parsed by Moment JS)\n     * @param {Boolean} [scheduleData.specialHours=false] Is this schedule data part of schedule special hours?\n     * @param {String} [scheduleData.type=Operating] The schedule type. Normal schedules should always be \"Operating\", \"Closed\" or \"Refurbishment\". Special schedules can be any String (eg. Extra Magic Hours).\n     * @returns {Boolean} success \n     */\n    SetRange({\n        // first date of the range to set schedule for\n        startDate = null,\n        // first date of the range to set schedule for\n        endDate = null,\n        // opening time for this day\n        openingTime = null,\n        // closing time for this day\n        closingTime = null,\n        // is this special hours data? (default: false)\n        specialHours = false,\n        // the type of this schedule date (default: Operating)\n        type = \"Operating\"\n    }) {\n        // check our input dates are valid\n        startDate = parseDateTime(startDate, \"startDate\");\n        endDate = parseDateTime(endDate, \"endDate\");\n        openingTime = parseDateTime(openingTime, \"openingTime\");\n        closingTime = parseDateTime(closingTime, \"closingTime\");\n\n        // if any of our dates are invalid, return false\n        if (!startDate || !endDate || !openingTime || !closingTime) return false;\n\n        // if any of our dates result in invalid data, return false\n        var retValue = true;\n\n        // add each day using SetDate\n        for (var m = startDate; m.isSameOrBefore(endDate); m.add(1, \"days\")) {\n            // retValue AND= means this becomes false with any one failed result\n            //  if we do fail, we also just keep going to try and get as much done as possible :) \n            retValue &= this.SetDate({\n                date: m,\n                openingTime: openingTime,\n                closingTime: closingTime,\n                specialHours: specialHours,\n                type: type\n            });\n        }\n\n        return retValue;\n    }\n\n    /**\n     * Get schedule data for a specific date\n     * @param {Object} dateData\n     * @param {Moment|String} dateData.date Moment.js date object to fetch schedule data for (or a valid date String to be parsed by Moment JS)\n     * @return {ScheduleData} scheduleResult Can be false if no data exists for the requested date\n     */\n    GetDate({\n        date = null\n    }) {\n        // check our date is valid\n        date = parseDateTime(date, \"date\");\n        if (!date) return false;\n\n        // do we have this day in our schedule data?\n        var day = dateToDay(date);\n        if (!this[s_scheduleDates].has(day)) return false;\n\n        var dayData = this[s_scheduleDates].get(day);\n        // copy data into the return object (otherwise we end up modifying the actual date data!)\n        var returnObject = {\n            \"date\": dayData.date,\n            \"openingTime\": dayData.openingTime,\n            \"closingTime\": dayData.closingTime,\n            \"type\": dayData.type\n        };\n\n        // add special schedules if we have any!\n        if (this[s_scheduleDatesSpecial].has(day)) {\n            returnObject.special = this[s_scheduleDatesSpecial].get(day);\n        }\n\n        return returnObject;\n    }\n\n    /**\n     * Get schedule data for a range of dates\n     * @param {Object} dateData\n     * @param {Moment|String} dateData.startDate Moment.js date object to fetch schedule data from (or a valid date String to be parsed by Moment JS)\n     * @param {Moment|String} dateData.endDate Moment.js date object to fetch schedule data from (or a valid date String to be parsed by Moment JS)\n     * @return {ScheduleData[]} scheduleResult Can be an empty array if there is no valid data (won't be null)\n     */\n    GetDateRange({\n        startDate = null,\n        endDate = null,\n    }) {\n        // check start and end date are valid\n        startDate = parseDateTime(startDate, \"startDate\");\n        endDate = parseDateTime(endDate, \"endDate\");\n        if (!startDate || !endDate) return [];\n\n        // fetch each day of the range and add it to our result\n        var returnArray = [];\n        for (var m = startDate; m.isSameOrBefore(endDate); m.add(1, \"days\")) {\n            var dateSchedule = this.GetDate({\n                date: m\n            });\n            if (dateSchedule) {\n                returnArray.push(dateSchedule);\n            }\n        }\n\n        return returnArray;\n    }\n}\n\nfunction parseDateTime(dateObject, varName) {\n    // check if it's already a valid Moment object\n    if (!moment.isMoment(dateObject)) {\n        // try and parse if this is a string\n        var newDate = moment(dateObject, [\n            moment.ISO_8601,\n            settings.DefaultTimeFormat,\n            settings.DefaultDateFormat,\n            \"YYYY-MM-DD\",\n        ]);\n\n        // check if we ended up with a valid timestamp\n        if (!newDate.isValid()) {\n            Log(`Invalid scheduleData.${varName}:`, dateObject);\n            return false;\n        }\n\n        // use our successful string parse!\n        dateObject = newDate;\n    }\n\n    // we got this far, success! return the new Moment object (or the original one if it was always good!)\n    return dateObject;\n}\n\nfunction dateToDay(date) {\n    // calculate the day since Unix Epoch\n    //  .unix returns in UTC, so we convert to minutes and add on the utcOffset (then convert from minutes to days)\n    //  finally we Math.floor to round downwards to get the current day as an integer\n    return Math.floor(((date.unix() / 60) + date.utcOffset()) / 1440);\n}\n\nmodule.exports = Schedule;"]}