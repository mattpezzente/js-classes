{"version":3,"sources":["../../lib/disneytokyo/index.js"],"names":["cheerio","require","cookie","Moment","Park","GeoLocation","s_parkID","Symbol","s_parkKind","s_parkLocationMin","s_parkLocationMax","DisneyTokyoPark","options","name","park_id","Error","park_kind","location_min","location_max","Promise","resolve","GetRideNames","then","rideData","FetchWaitTimesURL","HTML","ParseWaitTimesHTML","rideTimes","rideID","rideObject","GetRideObject","id","WaitTime","FastPass","GetAcccessToken","access_token","HTTP","url","headers","encodeURIComponent","$","load","results","rides","i","ride","el","ride_data","ride_url","find","attr","ride_id_match","exec","text","indexOf","waitTime","length","parseInt","remove","isNaN","reject","today","tz","Timezone","FetchOpeningTimesForMonth","format","add","bind","month","forceJSON","body","entry","date","scheduleDate","Schedule","SetDate","openingTime","open_time_1","closingTime","close_time_1","cookieExpire","Cache","Wrap","randomGeoLocation","RandomBetween","data","nextUrl","lat","LatitudeRaw","lng","LongitudeRaw","follow_max","returnFullResponse","resp","GPSCookie","GPSExpiresIn","cookie_string","cookie_data","parse","tdrloc","diff","expires","Log","entries","str_id","name_yomi","module","exports","parent","S","latitude","longitude","readFileSync","__dirname","JSON","stringify"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\n\n// cherrio, our web scraping library\nvar cheerio = require(\"cheerio\");\n// cookie library for reading geocookie for wait times\nvar cookie = require(\"cookie\");\n\nvar Moment = require(\"moment-timezone\");\n\nvar Park = require(\"../park\");\nvar GeoLocation = require(\"../geoLocation\");\n\nvar s_parkID = Symbol();\nvar s_parkKind = Symbol();\nvar s_parkLocationMin = Symbol();\nvar s_parkLocationMax = Symbol();\n\n// token history (maybe we can just calculate it instead of fetching it??)\n// 25th 17:30: 2Gz2/J+AAhLVQsYnVWXzmFRR\n// 25th 18:00: 2Gz2/J+AAhLVQsYnVWXzmFRR\n// September 25th: 2Gz24oWAAhLVQsYnVWXzmFRS\n// September 5th:  2GH25YWLFRfNG9QlVGL1kV9XCg==\n// August 29th:    2GD2/J+AAhLVQsYnVWXzmVRe\n// August 28th:    2GD2/J+AAhLVQsYnVWXzmVRe\n// July 31st:      2GT24oWAAhLVQsYnVWXzllVW\n// July 13th:      2WP25ZibFADIA403VmPyl1ZQDbc=\n// May 31st:       2WX25YWLFRfNG9QlVGL1kVNUDQ==\n// May 30th:       2WX2/J+AAhLVQsYnVWXzlFVX\n// April 17th:     2mH24oWAAhLVQsYnVWXzlVdQ\n// April 16th:     2mH24pGaEwHIA403VmPyl1ZTDbU=\n\n/**\n * Implements the Tokyo Disneyland API framework.\n * @class\n * @extends Park\n */\nclass DisneyTokyoPark extends Park {\n    /**\n     * Create new DisneyTokyoPark Object.\n     * This object should not be called directly, but rather extended for each of the individual Tokyo Disneyland parks\n     * @param {Object} options\n     * @param {String} options.park_id Tokyo Disneyland API park ID\n     */\n    constructor(options = {}) {\n        options.name = options.name || \"Tokyo Disneyland Park\";\n\n        // inherit from base class\n        super(options);\n\n        // assign park configurations\n        if (!options.park_id) throw new Error(\"Missing park's API ID\");\n        this[s_parkID] = options.park_id;\n        if (!options.park_kind) throw new Error(\"Missing park's kind ID\");\n        this[s_parkKind] = options.park_kind;\n        // geoip range for generating valid cookie\n        //  specify as two Location points\n        if (!options.location_min || !(options.location_min instanceof GeoLocation)) throw new Error(\"Missing park's min location\");\n        if (!options.location_max || !(options.location_max instanceof GeoLocation)) throw new Error(\"Missing park's max location\");\n        this[s_parkLocationMin] = options.location_min;\n        this[s_parkLocationMax] = options.location_max;\n    }\n\n    // override Fastpass Getter to declare support for Fastpass\n    get FastPass() {\n        return true;\n    }\n\n    /**\n     * Refresh/Fetch new Wait Times for this Tokyo Disney Resort park\n     * @returns {Promise}\n     */\n    FetchWaitTimes() {\n        return new Promise((resolve) => {\n            // get ride names\n            this.GetRideNames().then((rideData) => {\n                // fetch wait times HTML page\n                this.FetchWaitTimesURL().then((HTML) => {\n                    // parse HTML data\n                    this.ParseWaitTimesHTML(HTML).then((rideTimes) => {\n                        for (var rideID in rideData) {\n                            // find ride object (using ride names, not actual wait time data)\n                            //  why? because when the park closes, the HTML page is empty\n                            //  so, we want to check each ride for data, if it's missing data, the park/ride is assumed closed\n                            var rideObject = this.GetRideObject({\n                                id: rideID,\n                                name: rideData[rideID]\n                            });\n\n                            if (rideObject) {\n                                if (rideTimes[rideID]) {\n                                    // update ride with new waittime data\n                                    rideObject.WaitTime = rideTimes[rideID].WaitTime;\n                                    rideObject.FastPass = rideTimes[rideID].FastPass;\n                                } else {\n                                    // ride isn't on the website. Most like park is closed, so set wait time to -1 to mark as inactive\n                                    rideObject.WaitTime = -1;\n                                }\n                            }\n                        }\n\n                        resolve();\n                    });\n                });\n            });\n        });\n    }\n\n    FetchWaitTimesURL() {\n        return this.GetAcccessToken().then((access_token) => {\n            return this.HTTP({\n                url: `http://info.tokyodisneyresort.jp/rt/s/realtime/${this[s_parkID]}_attraction.html`,\n                headers: {\n                    \"Cookie\": `tdrloc=${encodeURIComponent(access_token)}`\n                }\n            });\n        });\n    }\n\n    ParseWaitTimesHTML(HTML) {\n        // load HTML using cheerio\n        var $ = cheerio.load(HTML);\n\n        var results = {};\n\n        var rides = $(\".schedule .midArw\");\n        for (var i = 0, ride; ride = rides[i++];) {\n            var el = $(ride);\n            var ride_data = {};\n\n            // extract URL (finding ride name/id)\n            var ride_url = el.find(\"a\").attr(\"href\");\n            var ride_id_match = /attraction\\/detail\\/str_id:([a-z0-9_]+)/gi.exec(ride_url);\n\n            // if we can't get a ride ID, just continue\n            if (!ride_id_match) {\n                continue;\n            }\n\n            // got the ride ID!\n            ride_data.id = ride_id_match[1];\n\n            // get waiting time!\n            // first, check for rides under maintenance\n            if (\n                // ride down for refurb/off-season (closed all day)\n                el.text().indexOf(\"運営・公演中止\") >= 0\n                // ride unexpectedly closed\n                ||\n                el.text().indexOf(\"一時運営中止\") >= 0\n                // \"special type\" closed, for non-standard attractions such as walking experiences or transport\n                ||\n                el.text().indexOf(\"案内終了\") >= 0) {\n                // found the maintenance text, mark ride as inactive\n                ride_data.WaitTime = -1;\n            } else {\n                var waitTime = el.find(\".waitTime\");\n                if (!waitTime || !waitTime.length) {\n                    ride_data.WaitTime = 0;\n                } else {\n                    // extract number\n                    ride_data.WaitTime = parseInt(waitTime.remove(\"span\").text(), 10);\n                    // if we didn't get a number, time is unavailable! (but ride is still open)\n                    //  this usually means you have to go to the ride to get wait times, and they're not on the app\n                    if (isNaN(ride_data.WaitTime)) ride_data.WaitTime = -1;\n                }\n            }\n\n            // fast pass status\n            if (el.find(\".fp\").length) {\n                // does this ride have FastPass?\n                ride_data.FastPass = true;\n            } else if (el.find(\".fp-no\")\n                .length) {\n                // ride supports fastpass! but they've ran out\n                ride_data.FastPass = true;\n            } else {\n                // otherwise, assume no fastpasses for this ride\n                ride_data.FastPass = false;\n            }\n\n            results[ride_data.id] = ride_data;\n        }\n\n        return Promise.resolve(results);\n    }\n\n    FetchOpeningTimes() {\n        return new Promise(function(resolve, reject) {\n            // fetch 3 months of schedule data\n            var today = Moment().tz(this.Timezone);\n            this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\n                today.add(1, \"month\");\n                this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\n                    today.add(1, \"month\");\n                    this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\n                        resolve();\n                    }.bind(this), reject);\n                }.bind(this), reject);\n            }.bind(this), reject);\n        }.bind(this));\n    }\n\n    FetchOpeningTimesForMonth(month) {\n        return new Promise(function(resolve, reject) {\n            this.HTTP({\n                url: `http://www.tokyodisneyresort.jp/api/v1/wapi_monthlycalendars/detail/ym:${month}/`,\n                headers: {\n                    \"Referer\": `http://www.tokyodisneyresort.jp/en/attraction/lists/park:${this[s_parkID]}`,\n                    \"X-Requested-With\": \"XMLHttpRequest\"\n                },\n                forceJSON: true\n            }).then(function(body) {\n                if (!body || !body.entry) return reject(\"Failed to find data from TDR calendar\");\n\n                for (var date in body.entry) {\n                    if (body.entry[date][this[s_parkID]]) {\n                        var scheduleDate = Moment(date, \"YYYY/MM/DD\");\n                        this.Schedule.SetDate({\n                            date: scheduleDate,\n                            openingTime: Moment.tz(scheduleDate.format(\"YYYY-MM-DD\") + \" \" + body.entry[date][this[s_parkID]].open_time_1, \"YYYY-MM-DD HH:mm\", this.Timezone),\n                            closingTime: Moment.tz(scheduleDate.format(\"YYYY-MM-DD\") + \" \" + body.entry[date][this[s_parkID]].close_time_1, \"YYYY-MM-DD HH:mm\", this.Timezone),\n                        });\n                    }\n                }\n\n                resolve();\n            }.bind(this), reject);\n        }.bind(this));\n    }\n\n    /**\n     * Get the Geo-Locked access token for accessing Tokyo Disneyland wait times\n     * @returns {Promise<String>} tdrloc cookie needed for accessing wait time pages\n     */\n    GetAcccessToken() {\n        var cookieExpire;\n        return this.Cache.Wrap(\"geocookie\", function() {\n            return new Promise(function(resolve, reject) {\n                // generate a new geo cookie for accessing Tokyo ride data\n                var randomGeoLocation = GeoLocation.RandomBetween(this[s_parkLocationMin], this[s_parkLocationMax]);\n\n                // request cookie for accessing wait times using a random location in the park\n                this.HTTP({\n                    url: `http://info.tokyodisneyresort.jp/s/gps/${this[s_parkID]}_index.html`,\n                    data: {\n                        nextUrl: `http://info.tokyodisneyresort.jp/rt/s/realtime/${this[s_parkID]}_attraction.html`,\n                        lat: randomGeoLocation.LatitudeRaw,\n                        lng: randomGeoLocation.LongitudeRaw\n                    },\n                    headers: {\n                        \"Referer\": `http://www.tokyodisneyresort.jp/en/attraction/lists/park:${this[s_parkID]}`,\n                    },\n                    // don't actually follow the redirect, we just want the cookie\n                    follow_max: 0,\n                    // we are actually only interested in the headers, so get the full response, not the body\n                    returnFullResponse: true\n                }).then(function(resp) {\n                    if (resp && resp.headers && resp.headers[\"set-cookie\"] && resp.headers[\"set-cookie\"].length) {\n                        // hunt for the tdrloc cookie\n                        var GPSCookie, GPSExpiresIn = 60 * 30;\n                        for (var i = 0, cookie_string; cookie_string = resp.headers[\"set-cookie\"][i++];) {\n                            var cookie_data = cookie.parse(cookie_string);\n\n                            // search for any tdrloc cookie\n                            //  keep searching and keep the last set one\n                            //  their server usually sets it twice, first deleting it, then setting the correct one\n                            if (cookie_data && cookie_data.tdrloc) {\n                                GPSCookie = cookie_data.tdrloc;\n                                // parse cookie date to calculate expirey time in seconds\n                                GPSExpiresIn = Moment().diff(Moment(cookie_data.expires, \"ddd, DD-MMM-YYYY HH:mm:ss z\"), \"seconds\");\n\n                                // the cookie can actually be negative if the park is closed (weird, but OK)\n                                //  if this is so, keep the current one for 5 minutes and try again\n                                if (GPSExpiresIn < 0) {\n                                    GPSExpiresIn = 60 * 5;\n                                }\n                            }\n                        }\n\n                        // did we find the cookie?\n                        if (GPSCookie) {\n                            // set out-of-scope cookieExpire so we can tell the cache how long to keep this token\n                            //  take a little off to be safe (a minute)\n                            cookieExpire = GPSExpiresIn - 60;\n\n                            this.Log(`Fetched new TDR geo-cookie: ${GPSCookie}`);\n\n                            // return the new cookie\n                            resolve(GPSCookie);\n                        } else {\n                            return reject(\"Failed to find GPS Cookie from TDR website\");\n                        }\n                    } else {\n                        return reject(\"Missing GeoCookie from TDR response\");\n                    }\n                }.bind(this), reject);\n            }.bind(this));\n        }.bind(this), function() {\n            return cookieExpire;\n        }.bind(this));\n    }\n\n    /**\n     * Fetch English ride names from the API\n     * @returns {Promise<Object>} `rideID` to English names\n     */\n    GetRideNames() {\n        return this.Cache.Wrap(\"ridenames\", function() {\n            return new Promise(function(resolve, reject) {\n                // fetch ride names\n                this.HTTP({\n                    url: `http://www.tokyodisneyresort.jp/api/v1/wapi_attractions/lists/sort_type:1/locale:1/park_kind:${this[s_parkKind]}/`,\n                    forceJSON: true,\n                    headers: {\n                        \"Referer\": `http://www.tokyodisneyresort.jp/en/attraction/lists/park:${this[s_parkID]}`,\n                    },\n                }).then(function(body) {\n                    if (!body || !body.entries || !body.entries.length) {\n                        return reject(\"Failed to find entries in ride data response\");\n                    }\n\n                    // populate data\n                    var rideData = {};\n                    for (var i = 0, ride; ride = body.entries[i++];) {\n                        // use English if we can, fallback to yomi if we're missing an English name\n                        rideData[ride.str_id] = ride.name || ride.name_yomi;\n                    }\n\n                    return resolve(rideData);\n                }.bind(this), reject);\n            }.bind(this));\n        }.bind(this), 86400);\n    }\n}\n\nmodule.exports = DisneyTokyoPark;\n\nif (!module.parent) {\n    // test example wait times HTML page\n    var S = new DisneyTokyoPark({\n        latitude: 35.6277563214705,\n        longitude: 139.8811161518097,\n        park_id: \"tds\",\n        park_kind: 2,\n        location_min: new GeoLocation({\n            latitude: 35.6277563214705,\n            longitude: 139.8811161518097\n        }),\n        location_max: new GeoLocation({\n            latitude: 35.62465172824325,\n            longitude: 139.88948464393616\n        })\n    });\n\n    // fetch new test HTML file\n    /*S.FetchWaitTimesURL().then((HTML) => {\n        require(\"fs\").writeFileSync(__dirname + \"/test.html\", HTML);\n    });*/\n\n    // test parsing stored HTML file\n    var HTML = require(\"fs\").readFileSync(__dirname + \"/test.html\");\n    S.ParseWaitTimesHTML(HTML).then((data) => {\n        S.Log(JSON.stringify(data, null, 2));\n    });\n}"]}