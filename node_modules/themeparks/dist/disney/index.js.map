{"version":3,"sources":["../../lib/disney/index.js"],"names":["Park","require","GeoLocation","Schedule","Moment","random_useragent","Promise","s_disneyAPIResortID","Symbol","s_disneyAPIParkID","s_disneyAPIParkRegion","s_rideSchedules","s_rideTypes","api_accessTokenURL","api_accessTokenURLBody","api_accessTokenURLMethod","api_appID","api_baseURL","api_userAgent","getRandom","ua","osName","WaltDisneyWorldPark","options","name","timezone","latitude","longitude","useragent","resort_id","Error","park_id","park_region","ride_types","concat","expiresIn","Cache","Wrap","resolve","reject","HTTP","url","AuthURL","method","body","AuthString","forceJSON","then","access_token","Log","expires_in","ttlExpiresIn","parseInt","Math","ceil","bind","requestObject","GetAccessToken","headers","Authorization","Accept","Date","now","GetOpeningTimes","GetAPIUrl","FetchWaitTimesURL","data","region","waitTimeData","entries","GetFacilitiesData","facilitiesData","i","ride","indexOf","type","rideId","CleanRideID","id","rideObject","GetRideObject","rideStatus","waitTime","status","toLowerCase","WaitTime","postedWaitMinutes","FastPass","fastPass","fastpass","available","FastPassReturnTimeAvailable","startTime","endTime","FastPassReturnTimeStart","tz","Timezone","FastPassReturnTimeEnd","endFillDate","add","m","isBefore","rideScheduleData","GetDate","date","SetDate","rangeStart","format","rangeEnd","FetchScheduleTimesURL","scheduleData","activities","schedule","scheduleID","j","scheduleTime","schedules","newScheduleData","timeZone","openingTime","closingTime","specialHours","WDWParkID","WrapGlobal","WDWResortID","FetchFacilitiesURL","element","added","coordinates","locationIDX","location","relatedLocations","coordinateIDX","coordinate","locationName","trim","geoLoc","push","locations","fastPassPlus","APIBase","regexTidyID","ride_id","capture","exec","length","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\n\n// base Disney World park objects\nvar Park = require(\"../park.js\");\n\n// we're storing ride locations now, so include our location lib\nvar GeoLocation = require(\"../geoLocation.js\");\n\n// need schedule lib to store ride times\nvar Schedule = require(\"../schedule\");\n\n// Moment date/time library\nvar Moment = require(\"moment-timezone\");\n\n// random useragent generator\nvar random_useragent = require(\"random-useragent\");\n\n// include our Promise library\nvar Promise = require(\"../promise\");\n\n// Disney API configuration keys\nvar s_disneyAPIResortID = Symbol();\nvar s_disneyAPIParkID = Symbol();\nvar s_disneyAPIParkRegion = Symbol();\nvar s_rideSchedules = Symbol();\nvar s_rideTypes = Symbol();\n\n// API settings\nvar api_accessTokenURL = \"https://authorization.go.com/token\";\nvar api_accessTokenURLBody = \"grant_type=assertion&assertion_type=public&client_id=WDPRO-MOBILE.MDX.WDW.ANDROID-PROD\";\nvar api_accessTokenURLMethod = \"POST\";\nvar api_appID = \"WDW-MDX-ANDROID-3.4.1\";\nvar api_baseURL = \"https://api.wdpro.disney.go.com/\";\n\n// use the same user-agent for all WDW park requests\nvar api_userAgent = random_useragent.getRandom(function(ua) {\n    return (ua.osName == \"Android\");\n});\n\n/**\n * Implements the Walt Disney World API framework. All Disney parks use this one API.\n * @class\n * @extends Park\n */\nclass WaltDisneyWorldPark extends Park {\n    /**\n     * Create new WaltDisneyWorldPark Object.\n     * This object should not be called directly, but rather extended for each of the individual Disney parks\n     * @param {Object} options\n     * @param {String} options.resort_id Disney API resort ID\n     * @param {String} options.park_id Disney API park ID\n     * @param {String} options.park_region Disney API region ID\n     * @param {String[]} options.ride_types Array of attraction types to return when getting wait times, eg. [\"Attraction\", \"Entertainment\"]\n     */\n    constructor(options = {}) {\n        options.name = options.name || \"Walt Disney World Resort\";\n        options.timezone = options.timezone || \"America/New_York\";\n\n        // set resort's general center point\n        options.latitude = options.latitude || 28.3852;\n        options.longitude = options.longitude || -81.5639;\n\n        // use our userAgent generated randomly on bootup\n        options.useragent = api_userAgent;\n\n        // inherit from base class\n        super(options);\n\n        // grab disney API configuration settings (or throw an error if value is missing/null)\n        if (!options.resort_id) throw new Error(\"Missing park's resort ID\");\n        this[s_disneyAPIResortID] = options.resort_id;\n        if (!options.park_id) throw new Error(\"Missing park's API ID\");\n        this[s_disneyAPIParkID] = options.park_id;\n        if (!options.park_region) throw new Error(\"Missing park's region\");\n        this[s_disneyAPIParkRegion] = options.park_region;\n\n        // valid ride types to return\n        this[s_rideTypes] = options.ride_types || [\"Attraction\"];\n        // make sure ride types is an array\n        this[s_rideTypes] = [].concat(this[s_rideTypes]);\n\n        // store ride schedules separately and apply them when needed\n        this[s_rideSchedules] = {};\n    }\n\n    // override Fastpass Getter to declare support for FastPass\n    //  (all Disney parks offer Fastpass)\n    get FastPass() {\n        return true;\n    }\n\n    // override ride schedule getter to state this park supports ride schedules\n    get SupportsRideSchedules() {\n        return true;\n    }\n\n    /**\n     * Get our current access token\n     */\n    GetAccessToken() {\n        var expiresIn;\n        return this.Cache.Wrap(\"accesstoken\", function() {\n            return new Promise(function(resolve, reject) {\n                // request a fresh access token\n                this.HTTP({\n                    url: this.AuthURL,\n                    method: api_accessTokenURLMethod,\n                    body: this.AuthString,\n                    // Disney API doesn't want to return as application/JSON, so we'll manually parse it into a nice object\n                    forceJSON: true\n                }).then(function(body) {\n                    if (!body.access_token) {\n                        this.Log(\"Error body\", body);\n                        return reject(\"Returned access token data missing access_token\");\n                    }\n                    if (!body.expires_in) {\n                        this.Log(\"Error body\", body);\n                        return reject(\"Returned access token data missing expires_in\");\n                    }\n\n                    // parse expires_in into an int\n                    var ttlExpiresIn = parseInt(body.expires_in, 10);\n\n                    // The ttlExpiresIn is the maximum time the access_token is valid. \n                    // It's possible for the token to be given back just moments before\n                    // it is invalid. Therefore we should force the ttl value in the\n                    // cache lower than this value so requests don't fail.\n                    expiresIn = Math.ceil(ttlExpiresIn * .90);\n\n                    this.Log(`Fetched new WDW access_token ${body.access_token}, expires in ${body.expires_in}, caching for a maximum of ${expiresIn}`);\n\n                    // return our new access token\n                    return resolve(body.access_token);\n                }.bind(this), reject);\n            }.bind(this));\n        }.bind(this), function() {\n            return expiresIn;\n        }.bind(this));\n    }\n\n    /**\n     * Fetch a URL from the Disney API\n     */\n    GetAPIUrl(requestObject) {\n        return new Promise(function(resolve, reject) {\n            // get access token\n            this.GetAccessToken().then(function(access_token) {\n                // TODO - build request object\n                // make sure headers exist if they weren't set already\n                if (!requestObject.headers) requestObject.headers = [];\n                requestObject.headers.Authorization = \"BEARER \" + access_token;\n                requestObject.headers.Accept = \"application/json;apiversion=1\";\n                requestObject.headers[\"X-Conversation-Id\"] = \"WDPRO-MOBILE.MDX.CLIENT-PROD\";\n                requestObject.headers[\"X-App-Id\"] = api_appID;\n                requestObject.headers[\"X-Correlation-ID\"] = Date.now();\n\n                // make sure we get JSON back\n                requestObject.forceJSON = true;\n\n                // send network request\n                this.HTTP(requestObject).then(resolve, reject);\n\n            }.bind(this), reject);\n        }.bind(this));\n    }\n\n    /**\n     * Fetch this Disney Park's waiting times\n     * @returns {Promise}\n     */\n    FetchWaitTimes() {\n        return new Promise(function(resolve, reject) {\n            // fetch opening times before wait times (so we have opening times to inject into rides)\n            this.GetOpeningTimes().then(function() {\n                // fetch wait times URL\n                this.GetAPIUrl({\n                    url: this.FetchWaitTimesURL,\n                    // pass in park region also\n                    data: {\n                        region: this[s_disneyAPIParkRegion]\n                    }\n                }).then(\n                    // success!\n                    function(waitTimeData) {\n                        // check we have some data\n                        if (!waitTimeData || !waitTimeData.entries) {\n                            this.Log(\"Error data\", waitTimeData || \"null\");\n                            return reject(\"Invalid data returned by WDW API for FetchWaitTimes\");\n                        }\n\n                        // fetch facilities data to inject locations (coming soon) and fastPass availability\n                        this.GetFacilitiesData().then((facilitiesData) => {\n\n                            // apply each ride wait time\n                            for (var i = 0, ride; ride = waitTimeData.entries[i++];) {\n                                // skip any ride without a name, likely an invalid ride\n                                //  eg. the River Rogue Keelboats at DLP are dormant and invalid, but still have a ride object with no name\n                                if (!ride.name) {\n                                    continue;\n                                }\n\n                                // only keep actual attractions\n                                if (this[s_rideTypes].indexOf(ride.type) < 0) {\n                                    continue;\n                                }\n\n                                var rideId = CleanRideID(ride.id);\n\n                                // get the ride object for this ride (will create it if it doesn't exist)\n                                var rideObject = this.GetRideObject({\n                                    id: rideId,\n                                    name: ride.name,\n                                });\n\n                                let rideStatus = (ride.waitTime && ride.waitTime.status) ? ride.waitTime.status.toLowerCase() : \"\";\n                                if (rideStatus == \"down\") {\n                                    rideObject.WaitTime = -2;\n                                } else if (rideStatus == \"operating\") {\n                                    rideObject.WaitTime = ride.waitTime.postedWaitMinutes || 0;\n                                } else {\n                                    rideObject.WaitTime = ride.waitTime.postedWaitMinutes || -1;\n                                }\n\n                                // set fastpass status from facilities data\n                                if (facilitiesData[rideId]) {\n                                    rideObject.FastPass = facilitiesData[rideId] ? facilitiesData[rideId].fastPass : false;\n                                } else {\n                                    // no facilities data? fallback on live fastPass availability\n                                    rideObject.FastPass = (ride.waitTime &&\n                                        // check for both fastpass and fastPass\n                                        (ride.waitTime.fastpass && ride.waitTime.fastpass.available) ||\n                                        (ride.waitTime.fastPass && ride.waitTime.fastPass.available)\n                                    ) ? true : false;\n                                }\n\n                                // some Disney parks return fastpass return times! search them out\n                                if (ride.waitTime && ride.waitTime.fastPass) {\n                                    if (!ride.waitTime.fastPass.available) {\n                                        rideObject.FastPassReturnTimeAvailable = false;\n                                    } else {\n                                        if (ride.waitTime.fastPass.startTime && ride.waitTime.fastPass.endTime) {\n                                            // we have start and end return times! convert to Moment objects and set\n                                            rideObject.FastPassReturnTimeStart = Moment.tz(ride.waitTime.fastPass.startTime, \"HH:mm:ss\", this.Timezone);\n                                            rideObject.FastPassReturnTimeEnd = Moment.tz(ride.waitTime.fastPass.endTime, \"HH:mm:ss\", this.Timezone);\n                                        }\n                                    }\n                                }\n\n                                // apply any schedule data we've fetched from opening hour data\n                                if (this[s_rideSchedules][rideId]) {\n                                    var endFillDate = Moment().tz(this.Timezone).add(90, \"days\");\n                                    for (var m = Moment().tz(this.Timezone); m.isBefore(endFillDate); m.add(1, \"day\")) {\n                                        var rideScheduleData = this[s_rideSchedules][rideId].GetDate({\n                                            date: m\n                                        });\n                                        if (rideScheduleData) {\n                                            rideObject.Schedule.SetDate(rideScheduleData);\n                                        }\n                                    }\n                                }\n                            }\n\n                            return resolve();\n                        });\n                    }.bind(this),\n                    // error\n                    reject\n                );\n            }.bind(this), reject);\n        }.bind(this));\n    }\n\n    /**\n     * Fetch this Disney Park's opening times\n     * @returns {Promise}\n     */\n    FetchOpeningTimes() {\n        return new Promise(function(resolve, reject) {\n            // get today's date and add on a month to get a decent range of dates\n            var rangeStart = Moment.tz(this.Timezone).format(\"YYYY-MM-DD\");\n            var rangeEnd = Moment.tz(this.Timezone).add(30, \"days\").format(\"YYYY-MM-DD\");\n\n            this.GetAPIUrl({\n                url: this.FetchScheduleTimesURL,\n                data: {\n                    \"filters\": \"theme-park,Attraction\",\n                    \"startDate\": rangeStart,\n                    \"endDate\": rangeEnd,\n                    \"region\": this[s_disneyAPIParkRegion]\n                }\n            }).then(function(scheduleData) {\n                if (!scheduleData || !scheduleData.activities) {\n                    this.Log(`Missing activities from ${scheduleData}`);\n                    return reject(\"Missing activities data from opening times API\");\n                }\n\n                // parse each schedule entry\n                for (var i = 0, schedule; schedule = scheduleData.activities[i++];) {\n                    // skip if we're missing valid schedule data\n                    if (!schedule.schedule) continue;\n\n                    var scheduleID = CleanRideID(schedule.id);\n                    for (var j = 0, scheduleTime; scheduleTime = schedule.schedule.schedules[j++];) {\n                        var newScheduleData = {\n                            date: Moment.tz(scheduleTime.date, \"YYYY-MM-DD\", schedule.timeZone || this.Timezone),\n                            openingTime: Moment.tz(`${scheduleTime.date}T${scheduleTime.startTime}`, \"YYYY-MM-DDTHH:mm:ss\", schedule.timeZone || this.Timezone),\n                            closingTime: Moment.tz(`${scheduleTime.date}T${scheduleTime.endTime}`, \"YYYY-MM-DDTHH:mm:ss\", schedule.timeZone || this.Timezone),\n                            type: scheduleTime.type,\n                            // work out if these are special hours or not\n                            specialHours: (scheduleTime.type != \"Operating\" && scheduleTime.type != \"Closed\" && scheduleTime.type != \"Refurbishment\"),\n                        };\n\n                        // check if we've found the actual park's schedule\n                        if (scheduleID == this.WDWParkID) {\n                            // apply data to our schedule\n                            this.Schedule.SetDate(newScheduleData);\n                        } else {\n                            // else, we must be a ride! (or event/parade or something)\n\n                            // remember ride schedules and apply them when FetchWaitTimes is called\n                            if (!this[s_rideSchedules][scheduleID]) {\n                                this[s_rideSchedules][scheduleID] = new Schedule();\n                            }\n\n                            this[s_rideSchedules][scheduleID].SetDate(newScheduleData);\n                        }\n                    }\n                }\n\n                resolve();\n            }.bind(this), reject);\n        }.bind(this));\n    }\n\n    /**\n     * Get park facilities data\n     * Gives us data like whether a ride offers FastPass and their geo-location\n     */\n    GetFacilitiesData() {\n        // cache facilities data for 24 hours (this fetches all data for the resort, so cache at a resort level with a global wrap)\n        return this.Cache.WrapGlobal(`${this.WDWResortID}_facilities`, () => {\n            // fetch fresh facilities data\n            return this.GetAPIUrl({\n                url: this.FetchFacilitiesURL,\n                method: \"POST\"\n            }).then((data) => {\n                var facilitiesData = {};\n\n                for (var i = 0, element; element = data.added[i++];) {\n                    if (element.type != \"Attraction\") continue;\n\n                    // grab ride coordinates (there will be likely multiple)\n                    var coordinates = [];\n                    for (var locationIDX = 0, location; location = element.relatedLocations[locationIDX++];) {\n                        for (var coordinateIDX = 0, coordinate; coordinate = location.coordinates[coordinateIDX++];) {\n                            // each ride can have multiple locations\n                            //  think: railway, fastPass entrance etc.\n\n                            var locationName = coordinate.type.trim();\n\n                            // calculate name for this location\n                            if (locationName == \"Guest Entrance\") {\n                                // we have a \"Guest Entrance\", rather than calling it that, use the name of this location\n                                //  this helps for rides with multiple \"Guest Entrance\"s like the railroad\n                                locationName = location.name.trim();\n                            }\n\n                            var geoLoc = new GeoLocation({\n                                longitude: coordinate.longitude,\n                                latitude: coordinate.latitude\n                            });\n\n                            coordinates.push({\n                                location: geoLoc,\n                                name: locationName\n                            });\n                        }\n                    }\n\n                    // add this attraction to our collected data\n                    facilitiesData[CleanRideID(element.id)] = {\n                        name: element.name.trim(),\n                        locations: coordinates,\n                        // hilariously some parks call is \"fastPass\" and some \"fastPassPlus\"\n                        fastPass: element.fastPass && element.fastPass == \"true\" ? true : (element.fastPassPlus && element.fastPassPlus == \"true\" ? true : false)\n                    };\n                }\n\n                return Promise.resolve(facilitiesData);\n            }, Promise.reject);\n        }, 60 * 60 * 24);\n    }\n\n    /**\n     * The URL used to request this park's latest ride waiting times \n     * @type {String}\n     */\n    get FetchWaitTimesURL() {\n        // this is a separate function for any parks that need to override this\n        return `${this.APIBase}facility-service/theme-parks/${this.WDWParkID};destination\\u003d${this.WDWResortID}/wait-times`;\n    }\n\n    /**\n     * The URL used to request this park's schedule data\n     * @type {String}\n     */\n    get FetchScheduleTimesURL() {\n        return `${this.APIBase}mobile-service/public/ancestor-activities-schedules/${this.WDWResortID};entityType=destination`;\n    }\n\n    /**\n     * The URL used to request the park's facilities data\n     * @type {String}\n     */\n    get FetchFacilitiesURL() {\n        return `${this.APIBase}mobile-service/public/destinations/${this.WDWResortID};entityType\\u003ddestination/facilities?region=${this[s_disneyAPIParkRegion]}`;\n    }\n\n    /**\n     * Get the API base URL for WDW parks\n     * @type {String}\n     */\n    get APIBase() {\n        return api_baseURL;\n    }\n\n    /**\n     * Get the Auth URL for WDW parks\n     * @type {String}\n     */\n    get AuthURL() {\n        return api_accessTokenURL;\n    }\n\n    /**\n     * Get the Auth body used for requesting the auth token\n     * @type {String}\n     */\n    get AuthString() {\n        return api_accessTokenURLBody;\n    }\n\n    /**\n     * Get the internal WDW Park ID\n     * @type {String}\n     */\n    get WDWParkID() {\n        return this[s_disneyAPIParkID];\n    }\n\n    /**\n     * Get the internal WDW Resort ID\n     * @type {String}\n     */\n    get WDWResortID() {\n        return this[s_disneyAPIResortID];\n    }\n}\n\nvar regexTidyID = /^([^;]+)/;\n/**\n * Clean up a WDW ride id\n * IDs are usually in form [id];entityType=Attraction\n * This will tidy that up to just return the numeric ID portion at the start\n * @private\n */\nfunction CleanRideID(ride_id) {\n    var capture = regexTidyID.exec(ride_id);\n    if (capture && capture.length > 1) {\n        return capture[1];\n    }\n    return ride_id;\n}\n\n// export just the Base Disney Park class\nmodule.exports = WaltDisneyWorldPark;\n"]}